\chapter{Pattern matching}

\label{Capitolo 4}
Il \textbf{pattern matching} si occupa di ricercare un pattern $P$ in un testo
$T$. Si hanno:
\begin{itemize}
  \item \textbf{ricerca esatta}
  \item \textbf{ricerca approssimata}
\end{itemize}
\begin{definizione}
  Definiamo stringa come una sequenza di simboli appartenenti ad un dato
  alfabeto $\Sigma$, scritta come:
  \[X=x_1,\ldots,x_n,\,\,\,\forall x_i\in \Sigma\]
  ovviamente non è necessario che la stringa contenga tutti i simboli
  dell'alfabeto.\\
  Diamo alcune definizioni utili:
  \begin{itemize}
    \item $|X|$ indica la lunghezza della stringa
    \item $\varepsilon$ indica la stringa vuota
    \item $X[i]$ indica il carattere all'indice $i$ (partendo da 1 e non da 0)
    \item $X[i,j]$n indica la sottostringa che parte dall'indice $i$ e arriva
    all'indice $j$ (estremi inclusi). Inoltre se si hanno $i\neq j$ e $j\neq
    |X|$ si ha una \textbf{sottostringa propria}.\\
    (Esempio: per $X=bbaccbbaac$ ho la sottostringa $X[4,8]=ccbba$)
    \item $X[1,j]$ indico un \textbf{prefisso} (estremo finale incluso). Si ha
    inoltre il \textbf{prefisso proprio} se $j\neq |X|$ e si ha \textbf{prefisso
      nullo} se $j=0$ e si indica con $\varepsilon$.\\
    (Esempio: per $X=bbaccbbaac$ ho il prefisso $X[1,4]=bbac$)
    \item $X[i,|X|]$ indica un \textbf{suffisso} della stringa (estremi
    inclusi), di lunghezza $k=|X|-i+1$, avendo quindi il suffisso
    $X[|X|-k+1,|X|]$. Si ha inoltre che se ho $X[|X|,|X|+1]$ 
    allora ho il \textbf{suffisso nullo}, ovvero $\varepsilon$.\\
    (Esempio: per $X=bbaccbbaac$ ho il suffisso $X[8,10]=aac$ e il suffisso
    $X[11,10]=\varepsilon$)
    
\end{itemize} 
\end{definizione}
\begin{definizione}
  Definiamo il \textbf{pattern matching esatto} come la ricerca di tutte le
  occorrenze esatte di un pattern $P$ in un testo $T$.\\
  $P$ occorre esattamente in $T$, a partire dall'indice $i$ in $T$, sse:
  \[T[i,i+|P|-1]\mbox{ coincide con }P\]
  Quindi in output ho tutte le posizione $i$ nel testo tali per cui:
  \[T[i,i+m-1]\mbox{ coincide con }P\]
\end{definizione}
\begin{esempio}
  Dato il testo $T=bbaccbbaac$ e il pattern $P=ccbb$ ho un'occorrenza esatta a
  partire da $i=4$ nel testo.
\end{esempio}
L'algoritmo naive sarebbe quello di prendere una finestra $W$, di lunghezza $P$,
da far scorrere sul testo (avanzando ogni volta di un carattere). Ogni volta
tale finestra viene confrontata con $P$ confrontando tutti i caratteri e, in
caso di match, stampando in output l'indice di inizio della finestra sul
testo. Questo algoritmo è $O(|T|\cdot |P|)$ nel caso peggiore.\\ 
Questo algoritmo ignora le caratteristiche di testo e pattern, ignorando aspetti
che potrebbero accelerare la ricerca, trovabili tramite un'operazione di
preprocessamento.
\begin{definizione}
  Definiamo \textbf{distanza di edit} come il minimo numero di operazioni di
  sostituzione, cancellazione e inserimento di un unico simbolo per trasformare
  una stringa in un'altra (o viceversa). \\
  La distanza di edit tra due stringhe è simmetrica (anche se le operazioni
  saranno diverse il loro numero minimo sarà uguale).
\end{definizione}
\begin{esempio}
  Calcoliamo la distanza di edit tra $X_1=agtgcgt$ e $X_2=atgtgat$.\\
  Partiamo cancellando la $g$ in indice 2 di $X_1$:
  \[X_1=atgcgt\]
  \[X_2=atgtgat\]
  Inserisco quindi una ``a'' al penultimo indice di $X_1$:
  \[X_1=atgcgat\]
  \[X_2=atgtgat\]
  Infine sostituisco la ``c'' con una ``t'' all'indice 4 di $X_1$:
  \[X_1=atgtgat\]
  \[X_2=atgtgat\]
  Ho quindi una distanza di edit pari a 3.\\
  Per trasformare la seconda nella prima avrei dovuto inserire una ``g''
  all'indice 2 di $X_2$, cancellare la ``a'' al penultimo indice di $X_2$ e
  infine sostituire la ``t'' con una ``c'' al terzultimo indice di $X_2$. Si
  vede quindi come anche in questo caso avrei distanza di edit pari a 3.
\end{esempio}
\begin{definizione}
  Definiamo il \textbf{pattern matching approssimato} come la ricerca di
  occorrenze approssimate di un pattern $P$ in un testo $T$, con al più un certo
  errore $k$.\\
  Viene usata la \textnormal{distanza di edit}, che rappresenta l'errore che si
  commette nell'eguagliare una stringa con un altra.\\
  $P$ ha un'occorrenza approssimata in $T$, che finisce all'indice $i$, se
  esiste almeno una sottostringa $T[i-L+1,i]$ che ha distanza di edit con $P$ di
  al più $k$. $L$ è un certo valore non prevedibile in quanto sto ammettendo che
  il match sia su una stringa di lunghezza diversa da quella del
  pattern. Ovviamente in questo caso si possono avere più sottostringhe
  accettabili secondo i parametri richiesti.\\
  In output ho quindi tutte le posizioni $i$ di $T$ in cui finisce almeno una
  sottostringa che ha con $P$ distanza di edit al più uguale a $k$.
\end{definizione}
\begin{esempio}
  Prendiamo il testo $T=bbaccbbac$ e $P=ccbb$.\\
  Impongo $k=1$ e vedo che un match è ``ccbb'' terminante all'indice 6 del testo
  (avendo errore 1 massimo). Ovviamente ``ccbb'' terminante all'indice 7 va bene
  avendo errore nullo.\\
  
\end{esempio}
\begin{definizione}
  Definiamo \textbf{bordo} della stringa $X$, $B(X)$, che è il più lungo
  prefisso proprio che occorre come suffisso di $X$.
  \begin{esempio}
    Vediamo qualche esempio:
    \[X=baacagahabaac\implies B(X)=baac\]
    \[X=abababa\implies B(X)=ababa\]
    \[X=aaaaaa\implies B(X)=aaaaa\]
    \[X=aaaccbbaac\implies B(X)=\varepsilon\]
    \[X=aaaaaaaa\implies B(X)=aaaaaaa\]
  \end{esempio}
  Ovviamente può essere $\varepsilon$ (in primis se ho una stringa di lunghezza
  1).
\end{definizione}
\begin{definizione}
  Definiamo concatenazione tra una stringa $X$ e un simbolo $\sigma$ come:
  $X\sigma$
\end{definizione}
\begin{esempio}
  Dato $X=bba$ e $\sigma=d$ ho:
  \[X\sigma = bbad\]
\end{esempio}
\section{Pattern matching con automi}
Siamo nell'ambito del pattern matching esatto.\\
Ho un pattern di lunghezza $m$ e un testo di lunghezza $n$.\\
Abbiamo una fase di preprocessamento in tempo $O(m|\Sigma|)$ per calcolare la
funzione di transizione $\delta$.\\
Definiamo $\delta$ definita sul pattern $P$ come:
\[\delta:\{0,1,\ldots, m\}\times \Sigma\to\{0,\,\ldots, m\}\]
Quindi ad ogni coppia tra un simbolo e un intero tra 0 e $m$ corrisponde un
intero tra 0 e $m$. Nel dettaglio si hanno due casi:
\begin{enumerate}
  \item primo caso:
  \[\delta(j,\sigma)=j+1\iff j<m\land P[j+1]=\sigma\]

  \item secondo caso:
  \[\delta(j,\sigma)=k\iff P[j+1]\neq \sigma \lor j=m,\mbox{ con
    }k=|B(P[1,j]\sigma)|\]
  Con $k$ che è la lunghezza del bordo tra il prefisso corrente a cui viene
  concatenato il carattere $\sigma$. Si ha che $k\leq j$ per definizione (dato
  che sto calcolando il bordo su una stringa di lunghezza $j+1$). Con questa 
  transizione posso, eventualmente, andare ``indietro'' nel pattern ma comunque
  ``in avanti'' nell'automa.
\end{enumerate}
La transizione dallo stato $j$ allo stato $\delta(j,\sigma)$ avviene attraverso
il simbolo $\sigma$. Posso quindi passare allo stato $j+1$ o allo stato $k$.\\
Nell'automa avremo quindi gli archi etichettati coi simboli e i nodi
etichettati con gli indici da 0 a $m$.\\
Nella stringa gli indici partono comunque da 1 quindi l'indice 0 nelle formule
rappresenta una sorta di posizione prima dell'inizio della stringa. Qualora $k$
sia pari a 0 per la seconda formula mi sposto effettivamente in questo indice
posto prima della stringa (anche se avrò due stati diversi etichettati come 0
nell'automa).
\begin{esempio}
  Prendiamo il pattern:
  \[P=acacbabbaabac\]
  calcoliamo:
  \begin{itemize}
    \item $\delta(6,b)=7$ in quanto ho effettivamente $b$ come simbolo
    all'indice successivo a $6$, uso quindi la prima formula
    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$6$};
        \node[state] (q_1) [right=of q_0] {$7$};
        \path[->]
        (q_0) edge  node {b} (q_1);
      \end{tikzpicture}
    \end{center}
    \item $\delta(0,a)=1$, in quanto $a$ è il primo carattere, uso quindi la
    prima formula
     \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$0$};
        \node[state] (q_1) [right=of q_0] {$1$};
        \path[->]
        (q_0) edge  node {a} (q_1);
      \end{tikzpicture}
    \end{center}
    \item $\delta(6,c)=2$ in quanto devo usare la seconda formula e avere:
    \[|B(P[1,6]c)|=|B(acacbac)|=|ac|=2\]
    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$6$};
        \node[state] (q_1) [right=of q_0] {$2$};
        \path[->]
        (q_0) edge  node {c} (q_1);
      \end{tikzpicture}
    \end{center}
    
    \item $\delta(0,c)=0$ in quanto devo usare la seconda formula e avere:
    \[|B(P[1,0]c)|=|B(c)|=|\varepsilon|=0\]
    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$0$};
        \node[state] (q_1) [right=of q_0] {$0$};
        \path[->]
        (q_0) edge  node {c} (q_1);
      \end{tikzpicture}
    \end{center}
    \item $\delta(13,a)=4$ in quanto devo usare la seconda formula e avere:
    \[|B(P[1,13]a)|=|B(acacbabbaabaca)|=|aca|=3\]
    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$13$};
        \node[state] (q_1) [right=of q_0] {$3$};
        \path[->]
        (q_0) edge  node {a} (q_1);
      \end{tikzpicture}
    \end{center}
  \end{itemize}
\end{esempio}
Facciamo due osservazioni:
\begin{enumerate}
  \item dallo stato 0 si arriva allo stato 0 per qualsiasi simbolo $\sigma\neq
  P[1]$ e quindi si arriva allo stato 1 attraverso $\sigma =P[1]$
  \item dallo stato $m$ si arriva sempre ad uno stato $k\leq m$ e da uno stato
  $m$ si può arrivare di nuovo ad uno stato $m$
\end{enumerate}
\begin{esempio}
  Se ho $P=aaaaaa$:
  \[\delta(6,a)=6\]
  in quanto:
  \[l=|B(aaaaaaa)|=|aaaaaa|=6\]
\end{esempio}
\begin{esempio}
  Sia dato un pattern $P=acacbac$, con $m=7$ e $\sigma=\{a,b,c\}$.\\
  Si hanno le seguenti transizioni $\delta(j,\sigma)$, calcolate solo sulla base
  delle formule.\\
  Parto con $\delta(j,\sigma)=j+1$:
  \begin{table}[H]
    \centering
    \begin{tabular}[H]{c||c|c|c}
      $j\backslash\sigma$ & a & b & c\\
      \hline
      \hline
      0 & 1 & & \\
      1 & & & 2\\
      2 & 3 & & \\
      3 & & & 4\\
      4 & & 5 & \\ 
      5 & 6 & & \\
      6 & & & 7\\
      7 & & &       
    \end{tabular}
  \end{table}
  Proseguo con $\delta(j,\sigma)=k$:
  \begin{table}[H]
    \centering
    \begin{tabular}[H]{c||c|c|c}
      $j\backslash\sigma$ & a & b & c\\
      \hline
      \hline
      0 & 1 & 0 & 0\\
      1 & 1 & 0 & 2\\
      2 & 3 & 0 & 0\\
      3 & 1 & 0 & 4\\
      4 & 3 & 5 & 0\\ 
      5 & 6 & 0 & 0\\
      6 & 1 & 0 & 7\\
      7 & 3 & 0 & 0      
    \end{tabular}
  \end{table}
\end{esempio}
In realtà algoritmo procede per induzione di riga in riga, riempendo la riga
basandosi con quella precedente, in $O(m|\Sigma|)$.\\
\newpage
\begin{esempio}
  Sia dato un pattern $P=acacbac$, con $m=7$ e $\sigma=\{a,b,c,d\}$.\\
  Aggiungo quindi un simbolo non appartenente al pattern, si ottiene:
   \begin{table}[H]
    \centering
    \begin{tabular}[H]{c||c|c|c|c}
      $j\backslash\sigma$ & a & b & c & d\\
      \hline
      \hline
      0 & 1 & 0 & 0 & 0\\
      1 & 1 & 0 & 2 & 0\\
      2 & 3 & 0 & 0 & 0\\
      3 & 1 & 0 & 4 & 0\\
      4 & 3 & 5 & 0 & 0\\ 
      5 & 6 & 0 & 0 & 0\\
      6 & 1 & 0 & 7 & 0\\
      7 & 3 & 0 & 0 & 0      
    \end{tabular}
  \end{table}
  Si aggiunge quindi una colonna di soli 0
\end{esempio}

\begin{esempio}
  Individuare un pattern sconosciuto di 6 caratteri e la tabella incompleta con
  solo $\delta(j,\sigma)=j+1$:
  \begin{table}[H]
    \centering
    \begin{tabular}[H]{c||c|c|c|c}
      $j\backslash\sigma$ & a & b & c & d\\
      \hline
      \hline
      0 & 1 &  &  & \\
      1 &  &  & 2 & \\
      2 &  & 3 &  & \\
      3 & 4 &  &  & \\
      4 & 5 &  &  & \\ 
      5 &  &  &  & 6\\
      6 &  &  &  &   
    \end{tabular}
  \end{table}
  Quindi banalmente il pattern è:
  \[P=acbaad\]
  Completo quindi la tabella con $\delta(j,\sigma)=k$:
  \begin{table}[H]
    \centering
    \begin{tabular}[H]{c||c|c|c|c}
      $j\backslash\sigma$ & a & b & c & d\\
      \hline
      \hline
      0 & 1 & 0 & 0 & 0\\
      1 &  1& 0 & 2 &0 \\
      2 &  1& 3 & 0 & 0\\
      3 & 4 & 0 & 0 & 0\\
      4 & 5 & 0 &2  &0 \\ 
      5 & 1 & 0 & 2 & 6\\
      6 & 1 & 0 & 0&  0 
    \end{tabular}
  \end{table}
\end{esempio}

\begin{esempio}
  Individuare un pattern sconosciuto di 6 caratteri e 3 simboli e la tabella
  incompleta:
  \begin{table}[H]
    \centering
    \begin{tabular}[H]{c||c|c|c}
      $j\backslash\sigma$ & a & b & c \\
      \hline
      \hline
      0 &  &    & 1\\
      1 & 2 &    & \\
      2 &  &    & \\
      3 &  &    & \\
      4 &  &    & \\ 
      5 &  &    & \\
      6 &  &    & 3  
    \end{tabular}
  \end{table}
  specifico i primi tre caratteri e gli ultimi due (il quarto non è
  ritrovabile).\\
  Quindi il pattern è:
  \[P=cac.ca\]
  per gli ultimi due sappiamo che avendo bordo 3 quindi gli ultimi due sono
  sicuro $ca$. Per le prime due uso la classica formula
  $\delta(j,\sigma)=j+1$. Per il terzo sfrutto l'ultima cella che ha segnato 3,
  che non è uno stato successivo ma ho il passaggio dallo stato 6 al 3 con c,
  implicando la lunghezza del bordo che calcolo sul pattern intero con $c$
  aggiunto è lungo 3 e quindi i primi tre simboli del pattern si ripetono negli
  ultimi 3 di questo pattern a cui è concatenato c. Quindi in 3 avrò c e in 5 e
  6 ca. Sul quarto carattere non posso dire nulla.
\end{esempio}

Vediamo quindi l'uso della funzione di transizione per trovare tutte le
occorrenze esatte nel testo. Si scandisce il testo per scandire il
testo. Ricordiamo che il preprocessamento (che non vedremo) ha tempo
$O(m|\Sigma|)$ mentre la scansione del testo ha tempo $O(n)$ in $T$.
Il procedimento è:
\begin{itemize}
  \item si parte dallo stato iniziale $s_0=0$
  \item il testo $T$ viene letto dalla posizione 1 alla $n$
  \item per ogni posizione $q$ da 1 a $n$ è associato uno stato $s_q$ ottenuto
  con la transizione dallo stato precedente $s_{q-1}$ tramite il simbolo $T[q]$:
  
\end{itemize}
\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$s_0=0$};
      \node[state] (q_1) [right=of q_0]{$s_1$};
      \node[] (q_2) [right=of q_1]{$\cdots$};
      \node[state] (q_3) [right=of q_2]{$j$};
      \node[state, accepting] (q_4) [right=of q_3] {$s_q$};
      \node[] (q_5) [right=of q_4]{$\cdots$};
      \node[state] (q_6) [right=of q_5]{$s_n$};
      \path[->]
      (q_0) edge  node {T[1]} (q_1)
      (q_1) edge  node {T[2]} (q_2)
      (q_2) edge  node {T[q-1]} (q_3)
      (q_3) edge  node {T[q]} (q_4)
      (q_5) edge  node {T[n]} (q_6);
    \end{tikzpicture}
  \end{center}
Si hanno due supposizioni:
\begin{enumerate}
  \item si suppongache $j$ sia la lunghezza del più lungo prefisso di $P$ che ha
  un’occorrenza in $T$ che finisce in posizione $q-1$ (e che inizia quindi in
  posizione $q-j$)
  \item si supponga che $j$ sia lo stato $s_{q-1}$ a cui l'algoritmo arriva dopo
  aver letto il simbolo $T[q-1]$
\end{enumerate}
A questo si passa a $s_q=\delta(j,T[q])$. Il nuovo stato $s_q$ deve essere
calcolato. \\
Il calcolo di $s_q=\delta(j, T[q])$ si divide in due casi (anche se in realtà
poi sono tre):
\begin{enumerate}
  \item $j<m\,\,\,\land\,\,\,P[j+1]=T[Q]$, significa avere in $j+1$ lo stesso
  simbolo che ho appena letto:
  \begin{esempio}
    Si ha:
    \begin{table}[H]
      \centering
      \begin{tabular}{c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
        \hline
        & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 &14&15&16&17\\
        \hline
        T=&a& a & a& b& a& c &c &a &b &a&c&c&c&a &c &b &a\\
        \hline
      \end{tabular}
    \end{table}
    matchando dal carattere 2 di T:
    \begin{table}[H]
      \centering
      \begin{tabular}{c||c|c|c|c|c|c|c|c}
        \hline
        & 1 & 2 & 3 & 4 & 5 & 6 & 7 &8\\
        \hline
        P=&a& b & a& c& c& a &b &. \\
        \hline
      \end{tabular}
    \end{table}

  \end{esempio}
  Il prefisso $P[1,j+1]$ (quindi quando ho $j+1=m$) si ha un'occorrenza di $T$
  che inizia in $q-(j+a)+1$, dopo aver letto il simbolo $T[q]$:
  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]
      \node[state] (q_0) {$j$};
      \node[state] (q_1) [right=of q_0] {$j+1$};
      \path[->]
      (q_0) edge  node {T[q]} (q_1);
    \end{tikzpicture}
  \end{center}
  Ho quindi che \textbf{il prefisso $P[1,m]=P$ ha un'occorrenza su $T$ che
    inizia in posizione $q-m+1$}:
  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]
      \node[state] (q_0) {$m-1$};
      \node[state] (q_1) [right=of q_0] {$m$};
      \path[->]
      (q_0) edge  node {T[q]} (q_1);
    \end{tikzpicture}
  \end{center}
  
  \item $j<m\,\,\,\lor\,\,\,P[j+1]\neq T[Q]$, che a sua volta si divide in:
  \begin{enumerate}
    \item $j<m\,\,\,\land\,\,\,P[j+1]\neq T[Q]$ ad esempio:
    \begin{esempio}
      Si ha:
      \begin{table}[H]
        \centering
        \begin{tabular}{c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
          \hline
          & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 &14&15&16&17\\
          \hline
          T=&a& a & a& b& a& c &c &a &b &a&c&c&c&a &c &b &a\\
          \hline
        \end{tabular}
      \end{table}
      matchando dal carattere 2 di T:

      \begin{table}[H]
        \centering
        \begin{tabular}{c||c|c|c|c|c|c|c|c}
          \hline
          & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\
          \hline
          P=&a& b & a& c& c&a&c &. \\
          \hline
        \end{tabular}
      \end{table}
    \end{esempio}
    Si ha, con il bordo $k=B(P[1,j]T[q])$:
    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]
        \node[state] (q_0) {$j$};
        \node[state] (q_1) [right=of q_0] {$k$};
        \path[->]
        (q_0) edge  node {T[q]} (q_1);
      \end{tikzpicture}
    \end{center}
    Quindi \textbf{il prefisso $P[1,k]$ ha occorrenza su $T$ che inizia con il
      carattere $(q-k+1)$ del testo}. Faccio quindi un salto

    
    \item $j=m$, ad esempio:
    \begin{esempio}
      Si ha:
      \begin{table}[H]
        \centering
        \begin{tabular}{c||c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
          \hline
          & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 &14&15&16&17\\
          \hline
          T=&a& a & a& b& a& c &c &a &b &a&c&c&c&a &c &b &a\\
          \hline
        \end{tabular}
      \end{table}
      matchando dal carattere 2 di T:
      \begin{table}[H]
        \centering
        \begin{tabular}{c||c|c|c|c|c|c|c|c}
          \hline
          & 1 & 2 & 3 & 4 & 5 & 6 & 7 &8\\
          \hline
          P=&a& b & a& c& c& a&b &a \\
          \hline
        \end{tabular}
      \end{table}
    \end{esempio}
    Ho quindi un'occorrenza di $P$ in $T$ che finisce in $q-1$. Il prefisso
    $P[1,k]$ ha occorrenza in $T$ che un'occorrenza che inizia in $q-m$ e una
    che inizia in $q-k+1$. Lo stato iniziale $m$ indica un’occorrenza di $P$ in
    $T$. Lo stato di arrivo $k$ è sicuramente minore o uguale a $m$. Se $k = m$,
    allora esiste una nuova occorrenza di $P$ in $T$ che risulta essere
    sovrapposta con la precedente di $m-1$ simboli. \textbf{Il prefisso
    $P[1,k]$ ha occorrenza in $T$ che un'occorrenza che inizia in $q-k+1$}
    

    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]
        \node[state] (q_0) {$j=m$};
        \node[state] (q_1) [right=of q_0] {$k$};
        \path[->]
        (q_0) edge  node {T[q]} (q_1);
      \end{tikzpicture}
    \end{center}
  \end{enumerate}
  Per rendere più semplice lo studio sono in grassetto i punti chiave dei tre
  casi. 
\end{enumerate}
Gli ultimi due casi possono essere riassunti con $j\geq m$ e $f\geq j$:
\begin{center}
  \begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]
    \node[state] (q_0) {$j$};
    \node[state] (q_1) [right=of q_0] {$f$};
    \path[->]
    (q_0) edge  node {T[q]} (q_1);
  \end{tikzpicture}
\end{center}
\textbf{Il prefisso di $P$ di lunghezza $f$ occorre in $T$ in posizione
  $q-f+1$ e se $f = m$, allora $P$ occorre in $T$ alla posizione $q-m+1$}.\\
In sostanza quindi l'algoritmo procede con tre step:
\begin{itemize}
  \item Si  parte dallo stato iniziale $s_0=0$  e si effettua una scansione di
  $T$ dal primo all’ultimo simbolo
  \item per ogni posizione $q$ di $T$ si effettua la transizione dallo stato
  corrente $s$ al nuovo stato $f = \delta(s,T[q])$ 
  \item ogni volta che il nuovo stato $f$ coincide con $m=|P|$, viene prodotta
  in output l’occorrenza $q-m+1$  
\end{itemize}
Avendo quindi lo pseudocodice:
\begin{algorithm}
  \begin{algorithmic}
    \Function{Scan-Text}{$\delta$, T, m}
    \State $n\gets|T|$
    \State $s\gets 0$
    \For {$q\gets 1$ to $n$}
    \State $f\gets \delta(s, T[q])$
    \If {$f==m$}
    \State \textbf{print} $q-m+1$
    \EndIf
    \State $s\gets f$
    \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}
Si ha quindi complessità lineare nella lunghezza del testo sia nel caso migliore
che peggiore.
\begin{esempio}
  Vediamo un esempio di scansione del testo dati:
  \begin{table}[H]
    \centering
    \begin{tabular}{c||c|c|c|c|c|c|c|c|c|c|c|c|c}
      \hline
      & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 \\
      \hline
      T=&c& a & b& a& c& a &c &b &a &c&a&b&a\\
      \hline
    \end{tabular}
  \end{table}
  \begin{table}[H]
    \centering
    \begin{tabular}{c||c|c|c|c|c|c|c}
      \hline
      & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
      \hline
      P=&a& c & a& c& b& a &c \\
      \hline
    \end{tabular}
  \end{table}
  Sono dati, secondo la solita divisione:
  \begin{table}[H]
    \centering
    \begin{tabular}{c||c|c|c}
      $\delta(i,\sigma)$ & a & b & c\\
      \hline
      0 & 1 &  & \\
      1 &  &  & 2\\
      2 & 3 &  & \\
      3 &  &  & 4\\
      4 &  & 5 & \\
      5 & 6 &  & \\
      6 &  &  & 7\\
      7 &  &  & 
    \end{tabular}
  \end{table}
  \begin{table}[H]
    \centering
    \begin{tabular}{c||c|c|c}
      $\delta(i,\sigma)$ & a & b & c\\
      \hline
      0 & 1 & 0 & 0\\
      1 & 1 & 0 & 2\\
      2 & 3 & 0 & 0\\
      3 & 1 & 0 & 4\\
      4 & 3 & 5 & 0\\
      5 & 6 & 0 & 0\\
      6 & 1 & 0 & 7\\
      7 & 3 & 0 & 0
    \end{tabular}
  \end{table}
  inizio con solo lo stato iniziale:
  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \path[->]
      
      ;
    \end{tikzpicture}
  \end{center}

  leggo $c$ seguo la tabella e vado in $0$ da $0$:
  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};

      \path[->]
      (q_0) edge  node {c} (q_1)

      ;
    \end{tikzpicture}
  \end{center}
  leggo $a$ seguo la tabella e vado in $1$ da $0$:

\begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};


      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)

      ;
    \end{tikzpicture}
  \end{center}

  leggo $b$ seguo la tabella e vado in $0$ da $1$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)

      ;
    \end{tikzpicture}
  \end{center}
  leggo $a$ seguo la tabella e vado in $1$ da $0$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
     

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
     
      ;
    \end{tikzpicture}
  \end{center}
  leggo $c$ seguo la tabella e vado in $2$ da $1$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
         \node[state] (q_0) {$0$};
        \node[state] (q_1) [right=of q_0]{$0$};
        \node[state] (q_2) [right=of q_1]{$1$};
        \node[state] (q_3) [right=of q_2]{$0$};
        \node[state] (q_4) [right=of q_3] {$1$};
        \node[state] (q_5) [below=of q_4] {$2$};
     

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      
      ;
    \end{tikzpicture}
  \end{center}
  leggo $a$ seguo la tabella e vado in $3$ da $2$:


  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
        \node[state] (q_1) [right=of q_0]{$0$};
        \node[state] (q_2) [right=of q_1]{$1$};
        \node[state] (q_3) [right=of q_2]{$0$};
        \node[state] (q_4) [right=of q_3] {$1$};
        \node[state] (q_5) [below=of q_4] {$2$};
        \node[state] (q_6) [left=of q_5] {$3$};

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
     
      ;
    \end{tikzpicture}
  \end{center}
    leggo $c$ seguo la tabella e vado in $4$ da $3$:

    \begin{center}
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$0$};
        \node[state] (q_1) [right=of q_0]{$0$};
        \node[state] (q_2) [right=of q_1]{$1$};
        \node[state] (q_3) [right=of q_2]{$0$};
        \node[state] (q_4) [right=of q_3] {$1$};
        \node[state] (q_5) [below=of q_4] {$2$};
        \node[state] (q_6) [left=of q_5] {$3$};
        \node[state] (q_7) [left=of q_6] {$4$};


      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)

      ;
    \end{tikzpicture}
  \end{center}
    leggo $b$ seguo la tabella e vado in $5$ da $4$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
       \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
      \node[state] (q_5) [below=of q_4] {$2$};
      \node[state] (q_6) [left=of q_5] {$3$};
      \node[state] (q_7) [left=of q_6] {$4$};
      \node[state] (q_8) [left=of q_7] {$5$};
     

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)
      (q_7) edge  node {b} (q_8)
     
      ;
    \end{tikzpicture}
  \end{center}
  leggo $a$ seguo la tabella e vado in $6$ da $5$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
      \node[state] (q_5) [below=of q_4] {$2$};
      \node[state] (q_6) [left=of q_5] {$3$};
      \node[state] (q_7) [left=of q_6] {$4$};
      \node[state] (q_8) [left=of q_7] {$5$};
      \node[state] (q_9) [left=of q_8] {$6$};
      

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)
      (q_7) edge  node {b} (q_8)
      (q_8) edge  node {a} (q_9)
     
      ;
    \end{tikzpicture}
  \end{center}
    leggo $c$ seguo la tabella e vado in $7$ da $6$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
       \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
      \node[state] (q_5) [below=of q_4] {$2$};
      \node[state] (q_6) [left=of q_5] {$3$};
      \node[state] (q_7) [left=of q_6] {$4$};
      \node[state] (q_8) [left=of q_7] {$5$};
      \node[state] (q_9) [left=of q_8] {$6$};
      \node[state] (q_10) [below=of q_9] {$7$};

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)
      (q_7) edge  node {b} (q_8)
      (q_8) edge  node {a} (q_9)
      (q_9) edge  node {c} (q_10)
     
      ;
    \end{tikzpicture}
  \end{center}
  Essendo arrivati allo stato $m=7$, esiste un’occorrenzza di P in posizione
  $10-7+1 = 4 $.\\
  leggo $a$ seguo la tabella e vado in $3$ da $7$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
      \node[state] (q_5) [below=of q_4] {$2$};
      \node[state] (q_6) [left=of q_5] {$3$};
      \node[state] (q_7) [left=of q_6] {$4$};
      \node[state] (q_8) [left=of q_7] {$5$};
      \node[state] (q_9) [left=of q_8] {$6$};
      \node[state] (q_10) [below=of q_9] {$7$};
      \node[state] (q_11) [right=of q_10] {$3$};

     

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)
      (q_7) edge  node {b} (q_8)
      (q_8) edge  node {a} (q_9)
      (q_9) edge  node {c} (q_10)
      (q_10) edge  node {a} (q_11)
      
      ;
    \end{tikzpicture}
  \end{center}
  
  \newpage
  leggo $b$ seguo la tabella e vado in $0$ da $3$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
      \node[state] (q_5) [below=of q_4] {$2$};
      \node[state] (q_6) [left=of q_5] {$3$};
      \node[state] (q_7) [left=of q_6] {$4$};
      \node[state] (q_8) [left=of q_7] {$5$};
      \node[state] (q_9) [left=of q_8] {$6$};
      \node[state] (q_10) [below=of q_9] {$7$};
      \node[state] (q_11) [right=of q_10] {$3$};
      \node[state] (q_12) [right=of q_11] {$0$};

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)
      (q_7) edge  node {b} (q_8)
      (q_8) edge  node {a} (q_9)
      (q_9) edge  node {c} (q_10)
      (q_10) edge  node {a} (q_11)
      (q_11) edge  node {b} (q_12)

      ;
    \end{tikzpicture}
  \end{center}
    leggo $a$ seguo la tabella e vado in $1$ da $0$:

  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
       \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0]{$0$};
      \node[state] (q_2) [right=of q_1]{$1$};
      \node[state] (q_3) [right=of q_2]{$0$};
      \node[state] (q_4) [right=of q_3] {$1$};
      \node[state] (q_5) [below=of q_4] {$2$};
      \node[state] (q_6) [left=of q_5] {$3$};
      \node[state] (q_7) [left=of q_6] {$4$};
      \node[state] (q_8) [left=of q_7] {$5$};
      \node[state] (q_9) [left=of q_8] {$6$};
      \node[state] (q_10) [below=of q_9] {$7$};
      \node[state] (q_11) [right=of q_10] {$3$};
      \node[state] (q_12) [right=of q_11] {$0$};
      \node[state, accepting] (q_13) [right=of q_12] {$1$};

      \path[->]
      (q_0) edge  node {c} (q_1)
      (q_1) edge  node {a} (q_2)
      (q_2) edge  node {b} (q_3)
      (q_3) edge  node {a} (q_4)
      (q_4) edge  node {c} (q_5)
      (q_5) edge  node {a} (q_6)
      (q_6) edge  node {c} (q_7)
      (q_7) edge  node {b} (q_8)
      (q_8) edge  node {a} (q_9)
      (q_9) edge  node {c} (q_10)
      (q_10) edge  node {a} (q_11)
      (q_11) edge  node {b} (q_12)
      (q_12) edge  node {a} (q_13)
      ;
    \end{tikzpicture}
  \end{center}
  e mi fermo avendo concluso la scansione del testo. Ho trovato quindi solo una
  occorrenza che inizia all'indice 4.
\end{esempio}
\section{Algoritmo Knuth-Morris-Pratt}
Vediamo ora l'\textbf{algoritmo Knuth-Morris-Pratt (\textit{KMP})}.\\
Anche in questo caso si ha un preprocessing del pattern in tempo lineare alla
lunghezza del pattern $O(m)$. Si calcola una funzione di fallimento $\varphi$
per avere il preprocessamento. Si ha poi la scansione del testo in tempo $O(n)$.
\begin{definizione}
  Definiamo la funzione di fallimento, detta \textit{prefix function}
  $\varphi$: 
  \[\varphi:\{0,1, \ldots, \mathrm{m}\} \rightarrow\{-1,0,1, \ldots,
    \mathrm{m}-1\}\]
  tale che:
  \begin{itemize}
    \item $\varphi=|B(P[1,j])|$ se $1\leq j\leq m$
    \item $\varphi=-1$ se $j=0$
  \end{itemize}
\end{definizione}
\begin{esempio}
  Dato il pattern lungo 13:
  \begin{table}[H]
    \centering
    \begin{tabular}{c||c|c|c|c|c|c|c|c|c|c|c|c|c}
      \hline
      & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 \\
      \hline
      P=&a& b & c& a& b& a &a &b &c &a&b&a&b\\
      \hline
    \end{tabular}
  \end{table}
  ottengo:
   \begin{table}[H]
    \centering
    \begin{tabular}{c||c|c|c|c|c|c|c|c|c|c|c|c|c|c}
      \hline
      &0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 \\
      \hline
      $\varphi$=&-1& 0 & 0& 0& 1 &2 &1 &1 &2&3&4&5&6&2\\
      \hline
    \end{tabular}
  \end{table}
\end{esempio}
Ci serve una definizione ricorsiva di bordo:
\begin{definizione}
  Si hanno 4 punti:
  \begin{enumerate}
    \item il bordo della stringa vuota è la stringa vuota stessa:
    \[B(\varepsilon)=\varepsilon\]
    \item il bordo di una stringa di un solo carattere è la stringa vuota:
    \[B(\sigma)=\varepsilon\]
    
    \item il bordo $B(X\sigma)$ della concatenazione tra una stringa $X$ e il
    simbolo $\sigma$ è:
    \[B(X\sigma)=B(X)\sigma\iff X[|B(X)|+1]=\sigma\]
    \item il bordo $B(X\sigma)$ della concatenazione tra una stringa $X$ e il
    simbolo $\sigma$ è anche:
    \[B(X\sigma)= B(B(X)\sigma)\iff X[|B(X)|+1]\neq\sigma\]
  \end{enumerate}
\end{definizione}
% aggiumngere esempio
\begin{definizione}
  Vediamo il calcolo di $\phi$ per induzione.\\
  I primi passi sono immediati:
  \[\phi(0)=-1\]
  \[\phi(1)=0\]
  Possiamo quindi calcolare $\phi(j)$ per $j>1$ supponendo che $\phi$ sia nota
  per tutti gli indici in $[0,j-1]$.\\
  Si ha:
  \[B(P[1,j])=B(P[1, j-1]P[j])\]
  e diciamo che:
  \[k_1=|B(P[1, j-1])|=\phi(j-1)\]
  Scriviamo anche:
  \[B(P[1,j-1]) = P[1,k_1]\]
  e chiamiamo:
  \[k_2=|B(P[1,k_1])|=\phi(k_1)=\phi(\phi(j-1))\]
  Si hanno due casi:
  \begin{enumerate}
    \item si ha $P[k_1+1]=P[j]$ quindi si ha:
    \[B(P[1,j])=B(P[1,j-1])P[j]\]
    Ne segue che:
    \[|B(P[1,j])| = |B(P[1,j-1])| + 1 \]
    Ma sappiamo che:
    \[|B(P[1,j])| = |B(P[1,j-1])| + 1 = k1 + 1 = \phi(j-1) + 1\]
    e quindi:
    \[|B(P[1,j])| = \phi(j-1) + 1\]
    e quindi possiamo dire che:
    \[\phi(j) = \phi(j-1) + 1 \]
    \item si ha $P[k_1+1]\neq P[j]$ quindi:
    \[B(P[1,j]) = B(B(P[1,j-1]) P[j])\]
    e sostituendo con $B(P[1,j-1]) = P[1,k_1]$:
    \[B(P[1,j]) = B(P[1,k_1] P[j])\]
    
  \end{enumerate}
  A questo punto dovrei separare due sottocasi per il secondo caso:
  \begin{enumerate}
    \item $P[k_2+1] = P[j]$
    \item $P[k_2+1] \neq P[j]$
  \end{enumerate}
  e andrei avanti ricorsivamente (su slide approfondimento anche su secondo
  livello di ricorsione).\\
  In generale possiamo dire che aggiungere un valore $k_p$ tale per cui:
  \[P[k_p+1]=P[j]\]
  implica che:
  \[\phi(j)=k_p+1\]
  mentre trovare tutti i valori $k_p$ tali per cui:
  \[P[k_p+1]\neq P[j]\]
  implica che a un certo punto si raggiunge un $k_p = -1$, che implica che il
  bordo 
  di $P[1,j]=0$ e quindi:
  \[\phi(j)=0=k_p+1\]
  Riassumo quindi la procedura:
  \begin{itemize}
    \item inizializzo $\phi(0)=-1$ e $\phi(1)=0$ e $j=2$ (per gli argomenti di
    $\phi$ che sono quindi maggiori di 1)
    \item setto $k=\phi(j-1)$
    \item divido nel due casi:
    \begin{enumerate}
      \item se $P[k+1] = P[j] $:
      \begin{itemize}
        \item setto $\phi(j)=k+1$
        \item $j=j+1$
      \end{itemize}
      e ricomincio
      \item se $P[k+1] \neq P[j] $:
      \begin{itemize}
        \item setto $k=\phi(k)$
        \begin{itemize}
          \item se $k=-1$ setto $\phi(j)=k+1$ e $j=j+1$ e ricomincio 
          \item altrimenti torno a testare i due casi
        \end{itemize}
      \end{itemize}
    \end{enumerate}
  \end{itemize}
  \newpage
  Possiamo quindi scrivere lo pseudocodice:
  \begin{algorithm}[H]
    \begin{algorithmic}
      \Function{Prefix}{$P$}
      \State $m\gets |P|$
      \State $\phi(0)\gets -1$
      \State $\phi(0)\gets 0$
      \For {$j\gets 2$ \textbf{to} $m$}
      \State $k\gets \phi(j-1)$
      \While {$k\geq 0\land P[k+1]\neq P[j]$}
      \State $k \gets \phi(k)$
      \EndWhile
      \State $\phi(j)\gets k+1$
      \EndFor
      \State \textbf{return} $\phi$
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  \textbf{su slide esempio di esecuzione}
\end{definizione}
Passiamo quindi alla scansione del testo.\\
La scansione del testo $T$ alla ricerca  di  $P$ avviene tramite una finestra
$W$ di confronto lunga m simboli che scorre lungo $T$ da sinistra a destra,
inizialmente posizionata in corrispondenza della posizione $i=1$ di $T$. Per
ogni posizione $i$ di $W$, ogni simbolo di $P$ viene confrontato con
il corrispondente simbolo in $W$, procedendo da sinistra a destra. Se
tutti i simboli sono confrontati con successo, allora nella posizione $i$ di $T$
esiste un’occorrenza di $P$. La finestra viene poi spostata verso destra in
una nuova posizione $j$ e si ripete il confronto.\\
La finestra viene spostata a destra utilizzando la funzione $\phi$. Il confronto
riparte dal simbolo del testo che aveva dato un mismatch con il pattern nella
precedente posizione di $W$, avendo quindi una scansione in $O(n)$.\\
Studiamo meglio lo spostamento di $W$.\\
Se ho $W$ in $i$ su $T$ e ho il primo carattere di $P$ che determina un mismatch
con $T$ in posizione $j>1$ ho che il simbolo di mismatch su $T$ è in
$i+j-1$. Per definizione sappiamo che $k=phi(j-1)$ è la lunghezza del bordo del
prefisso $P[1,j-1]$. Si ha quindi che:
\begin{itemize}
  \item $P[1,k]$ ha un’occorrenza su $T$ che inizia in posizione $i$
  \item $P[1,k]$ ha un’occorrenza su $T$ che inizia in posizione
  \[p=i+j-k-1=i+j-\phi(j-1)-1\]
\end{itemize}
Quindi il salto di $W$ da $i$ a $p$ garantisce di non perdere occorrenze di $P$
e garantisce che i primi $k$ simboli di $P$ hanno un matching con $T$ a partire
dalla nuova posizione $p$. Posso quindi far ripartire il contorno per la nuova
posizione $p$ di $W$ dalle posizioni:
\begin{itemize}
  \item $i+j-1$ su $T$
  \item $k+1$ su $P$
\end{itemize}
Sposto quindi $W$ a $p=i+j-\phi(j-1)-1$ e i primi $k=\phi(j-1)$ simboli di $P$
non vengono più confrontati con i corrispondenti simboli su $T$ nella nuova
posizione di $W$.\\
Si hanno dei casi particolari:
\begin{itemize}
  \item se $\phi(j-1)=0$ sposto $W$ a $p=i+j-1$ e i primi $k=0$ simboli di $P$
  non vengono più confrontati con i corrispondenti simboli su $T$ nella nuova
  posizione di $W$ quindi il confronto riparte da $i+j-1$ su $T$ e dal primo
  simbolo su $P$
  \item se $j=1$ sposto $W$ a $p=i+1$ e i primi $k=-1$ simboli di $P$
  non vengono più confrontati con i corrispondenti simboli su $T$ nella nuova
  posizione di $W$ quindi il confronto riparte da $i+1$ su $T$ e dal primo
  simbolo su $P$
  \item se $j=m+1$ sposto $W$ a $p=i+m-\phi(m)$ e i primi $k=\phi(m)$ simboli di
  $P$ 
  non vengono più confrontati con i corrispondenti simboli su $T$ nella nuova
  posizione di $W$ quindi il confronto riparte da $i+m$ su $T$ e dal 
  simbolo in posizione $\phi(m)+1$ su $P$
\end{itemize}

Questo algoritmo, tramite uno studia di complessità ammortizzata, nonostante il
doppio ciclo, ha complessità $O(n)$.\\
\textbf{Su slide esempio di esecuzione.}
\begin{algorithm}
  \begin{algorithmic}
    \Function{KMP}{$P, T,\phi$}
    \State $m\gets |P|$
    \State $n\gets |T|$
    \State $j\gets 0$
    \For {$q\gets 1$ \textbf{to} $n$}
    \While {$j\geq 0\land P[j+1]\neq T[q]$}
    \State $j \gets \phi(j)$
    \EndWhile
    \State $j\gets j+1$
    \If {$j=m$}
    \State \textbf{return} $q-m+1$
    \EndIf
    \EndFor   
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo Knuth-Morris-Pratt}
\end{algorithm}
\section{Algoritmi shift-and}
\subsection{Algoritmo di Baeza-Yates e Gonnet}
Con questo algoritmo si ha il preprocessing del pattern $P$ di lunghezza $m$ in
tempo $O(|\Sigma|+m)$. Questo preprocessamento avviene tramite il calcolo di una
tabella $B$ di $|\Sigma|$ word di di bit $B_\sigma$, ognuna di lunghezza
$m$. Alla fine la scansione del testo $T$ di lunghezza $n$ è in $O(n)$.\\
Si sfrutta il paradigma \textbf{shift-and (esatto)} confrontando quindi delle
word binarie e non dei simboli.
\begin{definizione}
  L'operazione di \textbf{AND} definita su due word:
  \[w_1\mbox{ \textbf{AND} }w_2=w\]
  produce:
  \begin{itemize}
    \item $w[i]=1$ sse $w_1[i]\,\land w_2[i]=1$
    \item $w[i]=0$ altrimenti
  \end{itemize}
\end{definizione}
\begin{definizione}
  L'operazione di \textbf{or} definita su due word:
  \[w_1\mbox{ \textbf{or} }w_2=w\]
  produce:
  \begin{itemize}
    \item $w[i]=1$ sse $w_1[i]\,\lor w_2[i]=1$
    \item $w[i]=0$ altrimenti
  \end{itemize}
\end{definizione}
\begin{definizione}
  L'operazione di \textbf{RSHIFT} (shift a destra con MSB a 0) definita su una
  word: 
  \[\mathbf{RSHIFT}=w\]
  produce:
  \begin{itemize}
    \item $w[1]=0$
    \item $w[i]=w_1[i-1]$ con $2\leq i\leq |w|$
  \end{itemize}
  In pratica è lo spostamento dei bit di una posizione verso destra con bit più
  significativo a 0 (quindi visto che avrei il buco a sinistra lì metto 0).
\end{definizione}
\begin{definizione}
  L'operazione di \textbf{RSHIFT1} (shift a destra con MSB a 1) definita su una word:
  \[\mathbf{RSHIFT}=w\]
  produce:
  \begin{itemize}
    \item $w[1]=1$
    \item $w[i]=w_1[i-1]$ con $2\leq i\leq |w|$
  \end{itemize}
  In pratica è lo spostamento dei bit di una posizione verso destra con bit più
  significativo a 1 (quindi visto che avrei il buco a sinistra lì metto 1).
\end{definizione}
Si ha quindi che ogni word $B_\sigma$ è una word di $m$ bit $\{0,1\}$:
\[B_\sigma=b_1b_2,\ldots b_m\]
tale che:
\[b_i=B_\sigma[i]=1\iff P[i]=\sigma\]
\textbf{Esempio su slide.}\\
La tabella prodotta $B$ è quindi l'insieme delle word
$B_\sigma,\,\,\,\forall\,\sigma\in Sigma$
In pratica ho la tabelle con un numero di righe pari al numero di simboli. In
ogni riga ho una word dove a 1 ho solo gli elementi corrispondenti al carattere
della riga nel pattern (se $P=aba$ ho due righe: $B_a=101$ e $B_b=010$).\\
Si ha quindi il procedimento di calcolo:
\begin{enumerate}
  \item tutte le word di $B_\sigma$ sono inizializzate a bit di soli 0
  \item si inizializza una maschera $M$, che è una word di $m$ bit tutti uguali
  a 0 tranne il più significativo che è pari a 1
  \item si esegue una scansione di $P$ da sinistra verso destra, e per ogni
  posizione $i$ faccio:
  \begin{itemize}
    \item $B_{P[i]}=M\mbox{ \textbf{OR} }B_{P[i]}$
    \item $M=\mathbf{RSHIFT}(M)$
  \end{itemize}
\end{enumerate}
\begin{algorithm}
  \begin{algorithmic}
    \Function{Compute-B}{P}
    \State $m\gets |P|$
    \For {\textbf{every} $\sigma \in Sigma$}
    \State $B_\sigma \gets 00\ldots0$
    \EndFor
    \State $M \gets 10\ldots0$
    \For {$i\gets 1$ \textbf{to} $m$}
    \State $\sigma \gets P[i]$
    \State $B_\sigma \gets M\mbox{ \textbf{OR} }B_\sigma$
    \State $M=\mathbf{RSHIFT}(M)$
    \EndFor
    \State \textbf{return}
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per il calcolo di $B$}
\end{algorithm}
Per la scansione del testo introduciamo la notazione:
\[P[1,i]=suff(T[1,j])\]
per indicare il prefisso lungo $i$ sul pattern $P$ occorre esattamente come il
suffisso di $T[1,j]$.
\begin{definizione}
  Dato un indice $j$, con $0\leq j\leq n$, con $n=|T|$, $D_j$ è una word di bit:
  \[D_J=d_1d_2\ldots d_m\]
  tale che:
  \[d_i=D_j[i]=1\iff P[1,i]=suff(T[1,j])\]
\end{definizione}
\begin{esempio}
  Preso:
  \[T=abcbcbcabaadc\]
  e:
  \[P=cbcbca\]
  Ottengo, ad esempio:
  \[D_7=101010\]
\end{esempio}
In pratica avanzo sul pattern è verifico se il prefisso mano a mano occorre come
suffisso nella prima parte del testo (parte definita da $j$ di $D_j$ che voglio
calcolare). Avanzando sul pattern se ho il prefisso coincide con quel suffisso
coincide metto 1, altrimenti 0 e poi aggiungo un carattere al prefisso avanzando
fino alla fine del pattern.\\
La word $D_0$ (ricordiamoci per l'indice inizia con 1 quindi è la word
relativa ad un indice prima di quello reale) è per definizione:
\[D_==00\ldots 0\]
poiché nessun prefisso di $P$ occorre come suffisso del prefisso nullo
$T[0,0]$.\\
La word $d_m=D_j[m]=1$ sse $P[1,m]=suff(T[1,j])$ quindi tutto il pattern ha
un'occorrenza che finisce in posizione $j$ sul testo $T$ e che inizia in
$j-m+1$.\\
Vediamo quindi come funziona la scansione del testo.\\
\begin{enumerate}
  \item si inizia dalla word $D_0=00\ldots0$
  \item per ogni valore di $j$ da 1 a $n=|T|$ calcolo $D_j$ a partire da
  $D_{j-1}$ che è stata calcolata al passo precedente
  \item ogni volta che $D_j$ ha l'ultimo bit uguale a $1$ ho in output $j-m+1$
  che è l'inizio dell'occorrenza di $P$ su $T$
\end{enumerate}
Bisogna capire come calcolare $D_j$ partendo da $j-1$:
\begin{itemize}
  \item se $i>1$:
  \[D_j[i]=1\iff P[1,i]=suff(T[1,j])\]
  ma questo può essere riscritto come:
  \[D_j[i]=1\iff P[1,i-1]=suff(T[1,j-1])\mbox{ \textbf{AND} }P[i]=T[j]\]
  ma la cosa può essere semplificata sapendo che $P[1,i-1]=suff(T[1,j-1])\iff
  D_{j-1}[i-1]=1$ e quindi posso dire che:
  \[D_j[i]=1\iff  D_{j-1}[i-1]=1\mbox{ \textbf{AND} }P[i]=T[j]\]
  ma sapendo che $P[i]=T[j]\iff B_{T[j]}[i]=1$ ho che:
  \[D_j[i]=1\iff  D_{j-1}[i-1]=1\mbox{ \textbf{AND} }B_{T[j]}[i]=1\]
  Avendo un calcolo basato sulla logica, con verità a 1, possiamo anche
  riscrivere come:
  \[D_j[i]\iff  D_{j-1}[i-1]\mbox{ \textbf{AND} }B_{T[j]}[i]\]
  e quindi:
  \[D_j[i]=  D_{j-1}[i-1]\mbox{ \textbf{AND} }B_{T[j]}[i]\]
  Si ha quindi che l'i-simo bit di $D_j$ è l'\textbf{AND} logico tra
  l'(i-1)-esimo bit di $D_{j-1}$ e l'i-esimo bit di $B_\sigma$ in corrispondenza
  di $\sigma=T[j]$
  
  \item se $i=1$:
  \[D_j[1]=1\iff P[1,1]=suff(T[1,j])\]
  ma questo può essere arricchito come:
  \[D_j[1]=1\iff P[1,1]= suff(T[1,j])\iff P[1]=T[j]\]
  e quindi posso dire, aggiungendo in \textbf{AND} un 1 che non cambia il
  risultato: 
  \[D_j[1]=1\iff P[1,1]= suff(T[1,j])\iff 1\mbox{ \textbf{AND} }P[1]=T[j]\]
  Quindi il risultato non cambia se si effettua l'\textbf{AND} logico con un bit
  uguale a 1 e quindi si ha:
  \[D_j[1]=1\iff 1\mbox{ \textbf{AND} }P[1]=T[j]\]
  ma si ha che $P[1]=T[j]\iff B_{T[j]}[1]=1$ e quindi:
  \[D_j[1]=1\iff 1\mbox{ \textbf{AND} }B_{T[j]}[1]=1\]
  e quindi:
  \[D_j[1]\iff 1\mbox{ \textbf{AND} }B_{T[j]}[1]\]
  che avendo logica booleana su bit diventa:
  \[D_j[1]= 1\mbox{ \textbf{AND} }B_{T[j]}[1]\]
  Quindi il primo bit della parola $D_j$ è uguale all'\textbf{AND} logico tra 1
  e il primo bit della parola $B_\sigma$ in corrispondenza del simbolo
  $\sigma=T[j]$  
\end{itemize}
\textbf{Esempio di calcolo su slide.}\\
Nell'esempio si arriva a dire che:
\[D_j=\mathbf{RSHIFT1}(D_{j-1})\mbox{ \textbf{AND} }B_{T[j]}\]
Posso quindi approfondire l'algoritmo di scansione:
\begin{enumerate}
  \item si inizializza una maschera del tipo $M=00\ldots 1$ (solo l'ultimo bit è
  pari a 1)
  \item si inizializza $D_0=00\ldots 0$
  \item per $j$ compreso tra 1 e $n$ calcolo:
  \[D_j=\mathbf{RSHIFT1}(D_{j-1})\mbox{ \textbf{AND} }B_{T[j]}\]
  \item ogni volta che $D_j\mbox{ \textbf{AND }M}$ è diverso da $00\ldots0$ ho
  in output la posizione $j-m+1$ di inizio occorrenza $P$ su $T$
\end{enumerate}
Avendo quindi nel complesso complessità:
\[O(|\Sigma|+m+n)\]
\textbf{Su slide due esempi, uno di esecuzione e uno di calcolo più mirato.}
\begin{algorithm}
  \begin{algorithmic}
    \Function{BYG}{P, T}
    \State $B\gets \mbox{Compute-B}(P)$
    \State $n\gets |T|$
    \State $D\gets 00\ldots 0$
    \State $M\gets 00\ldots 1$
    \For {$j\gets 1$ \textbf{to} $m$}
    \State $\sigma\gets T[j]$
    \State $D\gets \mathbf{RSHIFT}(D)\mbox{ \textbf{AND} }B_\sigma$
    \If{$D\mbox{ \textbf{AND} }M\neq 0$}
    \State \textbf{return} $j-m+1$
    \EndIf
    \EndFor
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo di Baeza-Yates e Gonnet}
\end{algorithm}
\subsection{Algoritmo di Wu e Manber}
Vediamo ora un algoritmo di \textbf{ricerca approssimata} con paradigma
\textbf{shift-and} (\textit{esempi per ogni step su slide}).\\
Dato un pattern $P$ e un testo $T$, su alfabeto $\Sigma$, e una soglia d'errore
$k$, si ha che $P$ ha un'occorrenza approssimata su $T$ in posizione finale $j$
se esiste una sottostringa $[j-L+1,j]$ che ha distanza di edit con il pattern di
al più $k$.\\
In merito all'algoritmo \textbf{Wu Manber (\textit{WM})}, implementato ad
esempio da \textit{grep}, si ha un preprocessing del pattern di lunghezza $m$ in
$O(|\Sigma| +m)$ tramite il calcolo di una matrice $B$ di $|\Sigma|$ parole di
$m$ bit. La scansione del testo per cercare le occorrenze approssimate è in
$O(nk)$. Il preprocessing è come in Baeza-Yates.\\
Studiamo la scansione.
L'algoritmo effettua $k+1$ scansioni per un indice $h$, tale che $0\leq h\leq
k$, dove la $h$-sima iterazione trova tutte le occorrenze del pattern con al più
$h$ errori. Con $h$ nullo ho le occorrenze esatte. La generica iterazione $h=k$
trova tutte le occorrenze in output all'algoritmo, ritrovando anche tutte le
soluzioni degli step precedenti di $h$. Sembra ci sia ridondanza di calcolo ma
si vedrà che si ha memorizzazione di tutte le occorrenze con un numero più basso
di $h$ rispetto a quello che si sta verificando. La generica iterazione $h$
calcola $n$ parole $D_J^h$ lunghe $m$ bit tali che $D_J^h[m]=1$ sse per ha
un'occorrenza approssimata che finisce in $j$ con al più $h$ errori (a conferma
che con $h=0$ ho lo shift-and esatto).\\
Si denoti con:
\[P[1,i]=suff_h(T[1,j])\]
il fatto che $P[1,i]$ occorre come suffisso di $T[1,j]$ \textbf{con al più $h$
  errori}. \\
Definiamo quindi, per un pattern $P$ lungo $m$:
\[D_j^h=d_1d_2\ldots d_m\,\,\,0\leq j\leq n,\,\,\, 0\leq h\leq k\]
tale che:
\[d_i=D_j^h[i]=1\iff P[1,j]=suff_h(T[1,j])\]
ricordando che $D_j^h$ è una parola di $m$ bit.\\
In particolare:
\begin{itemize}
  \item $D_0^h$ è per definizione $h$ bit più significativi pari a 1 e gli altri
  0, ovvero:
  \[
    \begin{cases}
      D_0^h=1&\mbox{ se } i\leq h \mbox{ (prime $h$ posizioni da sinistra)}\\
      D_0^h=1&\mbox{ se } i> h\mbox{ (ultime $m-h$ posizioni da destra)}\\
    \end{cases}
  \]
  infatti sui ha che:
  \[
    \begin{cases}
      \forall i\leq h, P[1,i]=suff_h(T[1,0])\\
      \forall i>h, P[1,i]\neq suff_h(T[1,0])
    \end{cases}
  \]
  Ne segue che $D_0^0$, avendo $h$ nullo, è per definizione $00\ldots 0$
  \item $d_m=D_j^h[m]=1\iff [1,m] = suff_k(T[1,j])$, avendo un'occorrenza che
  finisce in $j$ con al più $h$ errori e quindi con al più $k$ errori, avendo:
  \[D_J^h[m]=1\implies D_j^k[m]=1\]
  per cui non devo ogni volta ricalcolare
  \item $D_j^0$ corrisponde a Baeza-Yates
\end{itemize}
Nel dettaglio vediamo l'algoritmo:
\begin{itemize}
  \item alla prima iterazione $h=0$ $T$ viene scandito per $j$ da 1 a $n$ per
  calcolare tutte le word $D_j^0$ (ovvero Baeza-Yates)
  \item alla generica iterazione $h>0$ per ogni posizione $j$ del testo $T$
  viene calcolata $D_j^h$
  \item all'ultima iterazione $h=k$, ogni volta che la word $D_j^h$ calcolata ha
  il bit meno significativo pari a 1 viene prodotta in output la posizione $j$ di
  fine match con al più $k$ errori (non potrei sapere quella iniziale a causa
  degli errori) 
\end{itemize}
Bisogna quindi calcolare $D_j^h$ per qualsiasi $h>0$ e $j>0$, avendo che per
$h=0$ e $j=0$ ho word note.\\
Abbiamo che,per $i>1$:
\begin{itemize}
  \item ho un primo caso:
  \[D_j^h[i]=1\iff P[1,i]=suff_h(T[1,j])\impliedby P[1,i-1] =
    suff_h(T[1,j-1])\]\[\land P[i] = T[j] \]
  e quindi:
  \[D_j^h[i]=1\impliedby P[1,i-1] = suff_h(T[1,j-1])\land P[i] = T[j] \]
  Ma sappiamo che:
  \[[1,i-1] = suff_h(T[1,j-1])\iff D_{j-1}^h[i-1]=1\]
  e quindi posso riscrivere:
  \[D_j^h[i]=1\impliedby D_{j-1}^h[i-1]=1\land P[i] = T[j] \]
  ma so anche che:
  \[P[i]=T[j]\iff B_{T[j]}[i] = 1\]
  e quindi:
  \[D_j^h[i]=1\impliedby D_{j-1}^h[i-1]=1\land B_{T[j]}[i] = 1\]
  tolgo gli 1 per lo stesso ragionamento fatto con Baeza-Yates (avendoch a e
  fare con bit), ottenendo:
  \[D_j^h[i]\impliedby D_{j-1}^h[i-1]\land B_{T[j]}[i]\]
  implicazioni a sinistra $\impliedby$ non la posso togliere avendo altri casi
  \item ho un secondo caso:
   ho un primo caso:
  \[D_j^h[i]=1\iff P[1,i]=suff_h(T[1,j])\impliedby P[1,i-1] =
    suff_h(T[1,j-1]) \]
  avendo quindi un errore in meno nel primo caso e quindi $P[i]$ e $T[j]$
  possono essere diversi.\\
  Riduco:
  \[D_j^h[i]=1\impliedby P[1,i-1] = suff_h(T[1,j-1]) \]
  ma ho che:
  \[P[1,i-1] = suff_h(T[1,j-1]) \iff D_{j-1}^{h-1}[i-1]=1\]
  quindi:
  \[D_j^h[i]=1\impliedby D_{j-1}^{h-1}[i-1]=1 \]
  e quindi:
  \[D_j^h[i]\impliedby D_{j-1}^{h-1}[i-1] \]
  \item caso 3:
  \[D^h_j[i] = 1 \iff P[1,i] = suff_h(T[1,j])\impliedby P[1,i] =
    suff_{h-1}(T[1,j-1])\]
  e quindi $T[j]$ genera un errore.\\
  Compatto in:
  \[D^h_j[i] = 1 \impliedby P[1,i] =    suff_{h-1}(T[1,j-1])\]
  ma so che:
  \[ P[1,i] = suff_{h-1}(T[1,j-1])\iff  D_{j-1}^{h-1}[i]=1\]
  e quindi:
  \[D^h_j[i] = 1 \impliedby D_{j-1}^{h-1}[i]=1\]
  che è:
  \[D^h_j[i]  \impliedby D_{j-1}^{h-1}[i]\]
  \item caso 4:
  \[d_J^H[i]=1\iff P[1,j]=suff_h(T[1,j])\impliedby P[1,i-1]=suf_{h-1}(T[1,j])\]
  avendo che $P[i]$ genera un errore.\\
  Ho quindi che:
  \[d_J^H[i]=1\impliedby P[1,i-1]=suf_{h-1}(T[1,j])\]
  ma:
  \[P[1,i-1]=suf_{h-1}(T[1,j])\iff D_j^{h-1}[i-1]=1\]
  quindi:
  \[d_J^H[i]=1\impliedby D_j^{h-1}[i-1]=1\]
  ovvero:
  \[d_J^H[i]=\impliedby D_j^{h-1}[i-1]\]

\end{itemize}
Metto quindi in or i 4 casi:
\[D_j^h[i]\impliedby D_{j-1}^h[i-1]\land B_{T[j]}[i]\]
\[\lor\]
\[D_j^h[i]\impliedby D_{j-1}^{h-1}[i-1] \]
\[\lor\]
\[D^h_j[i]  \impliedby D_{j-1}^{h-1}[i]\]
\[\lor\]
\[d_J^H[i]=\impliedby D_j^{h-1}[i-1]\]
e quindi:
\[D_j^h[i]\iff D_{j-1}^h[i-1]\land B_{T[j]}[i]\]
\[\lor\]
\[D_{j-1}^{h-1}[i-1] \]
\[\lor\]
\[ D_{j-1}^{h-1}[i]\]
\[\lor\]
\[ D_j^{h-1}[i-1]\]
e quindi posso mettere l'uguale:
\[D_j^h[i]= D_{j-1}^h[i-1]\land B_{T[j]}[i]\]
\[\lor\]
\[D_{j-1}^{h-1}[i-1] \]
\[\lor\]
\[ D_{j-1}^{h-1}[i]\]
\[\lor\]
\[ D_j^{h-1}[i-1]\]
Passando al caso $i=1$ ho che:
\[D_j^h[1]=1\]
per $h>0$ e $j>0$, ovvero $P[1,1]$ occorre sempre come suffisso di $T[1,j]$ con
al più $h$ errori.\\
Sostituisco $i=1$ nella formula per $i>1$:
\[D_j^h[1]= D_{j-1}^h[0]\land B_{T[j]}[i]\]
\[\lor\]
\[D_{j-1}^{h-1}[1] \]
\[\lor\]
\[ D_{j-1}^{h-1}[0]\]
\[\lor\]
\[ D_j^{h-1}[1]\]
Ma sapendo che:
\[D_{j-1}^h[0]=D_{j-1}^{h-1}[0]=D_j^{h-1}[0]=1\]
ho che:
\[D_j^h[1]=1\land B_{T[j]}[i]\]
\[\lor\]
\[1 \]
\[\lor\]
\[ D_{j-1}^{h-1}[0]\]
\[\lor\]
\[ 1\]
Quindi il risultato è sempre 1 come deve essere sulla base della definizione.\\
Posso quindi unire il tutto in un solo conto per $i\geq 1$,
usando \textbf{RSHIFT1}:
\[D_j^h[i]=  RSHIFT1(D_{j-1}^h)\land B_{T[j]}\]
\[\lor\]
\[ RSHIFT1(D_{j-1}^{h-1})\]
\[\lor\]
\[D_{j-1}^{h-1}\]
\[\lor\]
\[ RSHIFT1(D_j^{h-1})\]
In generale si ricorda che:
\[D^0_j=1\implies D_j^h[i]=1,h>0\]
o addirittura:
\[D^{h'}_j=1\implies D_j^{h'}[i]=1,h>h'\]
In generale si ha anche che:
\[D_j^h[i]=1\implies D_j^{h+1}[i+1]=1, i< m\]
o analogamente:
\[D_j^h[i]=1\implies D_j^{h+1}[i-1]=1, i>1\]
In generale si ha anche che:
\[|B(P)|=i\iff D_j[m]=1\]
e $i$ è la più grande posizione $<m$ tale che $D_j[i]=1$.\\
\textbf{Vari esercizi e una simulazione intera dell'algoritmo su slide.}
\begin{algorithm}
  \begin{algorithmic}
    \Function{WM}{P, T}
    \State $D_0^0\gets 00\ldots 0$
    \State $M\gets 00\ldots 1$
    \State $D_j^0=BYG(P,T)$
    \For {$h\gets 1$ \textbf{to} $k$}
    \State $D_0^h=$\textit{ word con $h$ bit più significativi a 1, resto a 0}
    \For {$j\gets 1$ \textbf{to} $n$}
    \State \textit{calcolo} $D_j^h$ \textit{con la formula dei 4 OR, usando
    RSHIFT1} 
    \If{$h=k\mbox{ \textbf{AND} }(D_j^h\mbox{ \textbf{AND} } M)\neq 00\ldots 0$}
    \State \textbf{return} $j$
    \EndIf
    \EndFor
    \EndFor
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo di WU Manber}
\end{algorithm}