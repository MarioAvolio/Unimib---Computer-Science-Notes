\chapter{Introduzione}
\section{Richiami di Teoria dei grafi e di Linguaggi}
Un grafo è definito come $G=(V,E)$, con $V$ insieme
dei vertici e $E$ insieme degli archi. Un grafo può essere \textit{orientato} o
\textit{non orientato}. Un \textbf{cammino} tra due vertici è una sequenza di
archi che mi porta da un vertice all'altro. Un cammino è detto \textbf{ciclo} se
il vertice sorgente coincide con quello di destinazione. Due vertici sono
\textbf{connessi} se esiste un cammino che li collega. Un \textbf{grafo
  connesso} è un grafo dove per ogni coppia di vertici si ha che essi sono
connessi. Se questo cammino è di un solo arco si parla di \textbf{grafo
  completo}, ovvero ogni vertice è \textbf{adiacente} ad ogni altro. Si parla di
\textbf{grafo pesato} se si ha una funzione $W$ che associa un peso ad ogni
arco. \\
Useremo anche la teoria dei linguaggi formali con $V$ alfabeto e stringhe
costruite su $V$. Con $\varepsilon$ abbiamo la stringa vuota e con $V^*$ è
l'insieme di tutte le possibili stringhe costruibili con quell'alfabeto, inclusa
la stringa vuota. $V^*$ è un insieme infinito. Con $V^+$ indico
$V^*/\varepsilon$, ovvero senza la stringa vuota. Un \textbf{linguaggio} $L$ è
un sottoinsieme di $V^*$, quindi $L\subseteq V^*$, che comprende tutti gli
elementi di $V^*$ che seguono una certa \textbf{proprietà} (o più
proprietà). Anche $L$ è un insieme infinito.\\
Un'altra nozione è quella di \textbf{problema}. Un problema computazionale è una
``questione'' a cui si cerca risposta. Più formalmente un problema è specificato
da \textbf{parametri} (l'\textit{input} del problema) e le \textbf{proprietà} che deve
soddisfare la \textbf{soluzione} (l'\textit{output}). L'\textbf{istanza} di un problema
specificando certi parametri in \textit{input} al problema (\textit{input} che devono essere
coerenti ai parametri richiesti).\\


% L'informatica è costruita su una logica matematica. Il punto di partenza è stato
% dettato da Turing (con la \textbf{macchina di Turing} (\textit{TM})) e questo
% pensiero si è poi sviluppato nel tempo. Turing, con la sua macchina logica, ha
% dimostrato che ci sono funzioni non calcolabili, verità logiche non
% dimostrabili.\\ Subito dopo la macchina di Turing nasce la teoria della
% \textbf{complessità   computazionale}, col fine di classificare il problemi in
% base alla difficoltà delle soluzioni mediante macchine di calcolo. Tale
% \textit{difficoltà} viene stimata rispetto a \textbf{spazio e tempo}. La teoria
% della \textbf{complessità computazionale} si riferisce a varie \textbf{classi
%   di complessità} che 
% classificano, in un primo approccio, \textit{problemi decisionali} descritti da
% funzioni binarie che hanno in \textit{input} una stringa sull'alfabeto $\{0,1\}$ e
% restituiscono un bit (o 0 o 1). Questo perché le macchine di Turing ragionano in
% binario. Si ha quindi:
% \[f:\{0,1\}^*\to {0,1}\]
% \textbf{Esistono problemi che si è dimostrato non essere risolvibili in tempo
%   efficiente.}\\
% Tra le classi abbiamo i \textbf{problemi NP} e \textbf{problemi P}. Inoltre i
% problemi NP sono a loro volta classificabili tra loro cercando i più difficili,
% ottenendo \textbf{problemi NP-hard} e \textbf{problemi NP-complete} (esistono
% varie dimostrazioni per la \textit{NP-completezza}).
% \section{Tempo di calcolo di una TM}
% \begin{definizione}
%   Sia $T:\mathbb{N}\to \mathbb{N}$ una funzione calcolabile da TM e $L\pi$ un
%   linguaggio di decisione (dove $\pi$ sta per ``problema'' e ``di decisione'' ci
%   ricorda che il risultato sarà binario) allora una \textbf{TM deterministica}
%   $M$ accetta L$\pi$ in tempo $T(n)$ se, $\forall x\in L\pi$, con $|x|=n$, $M$
%   accetta $x$ in $T(n)$ mosse o configurazioni
% \end{definizione}
% \begin{definizione}
%   Un \textbf{problema di decisione} $\pi$ riceve in \textit{input} un'istanza $x$ e
%   l'\textit{output} è:
%   \begin{itemize}
%     \item 0 che vuole dire \textit{no}
%     \item 1 che vuole dire \textit{yes}
%   \end{itemize}
%   Un linguaggio $L\pi$ restituisce 1 per tutti gli $x$ che appartengono al
%   linguaggio. Quindi $L\pi$ è l'insieme degli \textit{input} di $\pi$ su cui l'\textit{output} è
%   1 (è l'analogo della \emph{funzione caratteristica} di un insieme, ovvero la
%   funzione che risponde 1 sse un certo elemento appartiene all'insieme di
%   riferimento).\\
%   La \textbf{funzione associata al problema} si chiama $f\pi$ ed è la funzione
%   che dato un \textit{input} restituisce 1 sse l'\textit{input} appartiene al $L\pi$.
% \end{definizione}
% Approfondiamo ora lo studio della \textbf{classe P}.
% \begin{definizione}
%   La classe dei linguaggi di decisione accettati in tempo
%   $T(n)=cn^p,\,p\in\mathbb{N},\, p\neq 0$ da una TM deterministica è detta
%   \textbf{classe P}, quindi in un tempo polinomiale sulla dimensione dell'\textit{input}
%   $n$, è detta \textbf{classe P}. Quindi P è una classe di \textbf{problemi di
%     decisione}. \\
%   Potenzialmente $p$ potrebbe anche non essere un intero in quanto si potrebbero
%   avere tempi frazionari.
% \end{definizione}
% \begin{definizione}
%   Si definisce che $L\pi$ è accettato da una TM in tempo $T(n)$ se $\exists
%   \,\,T :\mathbb{N}\to \mathbb{N}$ calcolabile da TM e $\forall x\in L\pi$, con
%   $|x|=n$, la TM accetta $x$ e risponde 1 (\textit{yes}) in al più $T(n)$ mosse
%   di calcolo (dette anche configurazioni).\\
%   Nel caso del modello della macchina RAM si ha la stessa situazione con però
%   $T(n)$ \textbf{istruzioni RAM} e si dice che $L\pi$ è accettato dalla macchina
%   RAM (si può dire che è anche deciso dell'algoritmo A della macchina RAM). In
%   caso contrario la macchina RAM restituisce \textit{no}, in quanto si parla di
%   ``decisione'' oltre che di ``accettazione'' (a differenza della TM, dove però
%   si può ottenere lo stesso discorso parlando di TM complementare $M'$, che in
%   $T(n)$ mi risponderà yes alla richiesta che un \textit{input} non appartenga a
%   $L\pi$, altrimenti bisogna fissare un limite di tempo per ottenere yes).\\
%   È dimostrabile che se $L\pi$ è accettabile in tempo polinomiale allora nello
%   stesso tempo è anche decidibile.\\
%   La differenza tra accettazione e decisione sarà fondamentale nel
%   \textbf{modello non deterministico}.
% \end{definizione}
% \begin{shaded}
%   Si ricordi che il \textbf{modello RAM (\textit{Random Access Machine})} è
%   usato per studiare il tempo di calcolo di 
%   uno pseudocodice. È un modello teorico (una macchina teorica ``simile'' a
%   quelle reali) dotato di istruzioni come
%   \textit{load, store, add, etc$\ldots$} dove un codice (ipoteticamente in
%   qualsiasi linguaggio incluso lo pseudocodice) viene tradotto in una sorta di
%   linguaggio macchina (linguaggio RAM), dove $n$ è un intero rappresentante il
%   numero di istruzioni RAM necessarie per ottenere l'\textit{output} ($n$ è detto
%   \textbf{tempo uniforme}). Sul linguaggio RAM si può studiare anche lo spazio
%   calcolato come numero di bit necessari per la computazione (è detto
%   \textbf{costo logaritmico}). In questo secondo punto il costo di
%   un'istruzione, come ad esempio \textit{load(n)}, è logaritmico rispetto
%   all'operando $n$ ($\,\log_2 n$), studia quindi la \emph{dimensione}
%   dell'\textit{input}.
% \end{shaded}
% Consideriamo ora un modello basato su algoritmi.
% \begin{definizione}
%   Sia $L\pi$ un linguaggio di decisione e $t:\mathbb{N}\to\mathbb{N}$ una
%   funzione calcolabile, allora un algoritmo $A$ accetta $L\pi$ in tempo $T(n)$
%   sse $\forall x\in L\pi$, con $|x|=n$, $A$ termina su \textit{input} $x$ dopo $T(|x|)$
%   passi di calcolo, ovvero istruzioni esguite, producendo 1 come \textit{output}. Quindi
%   P è la classe dei linguaggi di decisione accettati in tempo
%   $T(n)=cn^p,\,p\in\mathbb{N}$ (con lo stesso discorso di sopra su $p$) da un
%   algoritmo $A$ in tempo polinomiale.
% \end{definizione}
